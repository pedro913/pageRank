\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amsthm,amssymb,bezier}
\usepackage[brazil]{babel}
\usepackage[onehalfspacing]{setspace}
\usepackage{indentfirst}
\usepackage{tikz}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    language=C, %% Troque para PHP, C, Java, etc... bash é o padrão
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{gray!10},
    frame=single,
    tabsize=2,
    title=\lstname,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    inputencoding=utf8,
    xleftmargin=70pt,
    xrightmargin=50pt,
}

\usetikzlibrary{arrows}
\setlength{\textwidth}{6.5in} \setlength{\textheight}{8.7in}
\setlength{\topmargin}{-0.65in} \setlength{\evensidemargin}{-1mm}
\setlength{\oddsidemargin}{-1mm}
\setlength{\parskip}{0.3\baselineskip}
\setlength{\fboxsep}{0.3cm}
\linespread{1.05}
\setlength\parindent{.25in}

\newenvironment{option}{\addtolength\parindent{0.5in}}

	\title{\textbf{Relatório do Projeto de MAP2110}}
	\author{Pedro Henrique Alves de Queiroz 11811180}
	\date{\today}
                       
\begin{document}
    
\maketitle

	
\section{Introdução}
    A Google foi criada em 1998 por Larry Page e Sergey Brin enquanto cursavam o Ph.D. na Universidade de Stanford. Ambos foram responsáveis pela criação do PageRank que é o sistema de busca responsável por grande parte do sucesso da Google. O PageRank é um algoritmo de busca de páginas que as ordena apartir da importância dela, sendo que a importância de cada página que depende das páginas para o qual ela aponta, é apontada. 
    
    Neste relatório explicaremos os métodos utilizados para cálculo da importância, bem como as ideias para construção do programa, complexidade, além da criação de testes e análise deles.   ***

\vspace{3em}

\section{Métodos}
	Ambos os métodos necessitam da construção da matriz de ligação
	Esse método consciste em dada uma matriz de ligação $M$ $n\times n$ transformamos $M$ em:
    	
    		\vspace{1em}
    		\centerline{$M = (1-\alpha)M + \alpha S_n$,} 
    		\vspace{0.3em}
    		
    	 	onde $\alpha$ é um valor entre 0 e 1 e $S_n$ é uma matriz com todos um valores iguais a $1/n$, afim de evitar possivéis colunas de zero ("quando temos uma página que não aponta para ninguém"). onde $\alpha$ é um valor entre 0 e 1 e $S_n$ é uma matriz com todos um valores iguais a $1/n$, afim de tornar a matriz positiva
e coluna estocástica, isto é, ***defina isso ao inves de explicar*** todos os valores da matriz maiores que 0 e a soma dos valores de cada coluna resulta em 1. ***

	 \subsection{Método 1 - Escalonamento}
    	\subsubsection{Visão geral}
    		Sendo $M$ uma matriz coluna estocástica, foi demonstrado na apresentação do projeto $(M - I)$ é singular, implicando que $det(M-I) = 0$ e na existência de um vetor $q$ não nulo tal que $(M-I)q = 0$. Portanto ao escalonarmos, por Eliminação Gaussiana, a matriz $A = M - I$, teremos a última linha de $A$ com valores iguais a 0 (já que os vetores das linhas são dependentes). Feito isso conseguimos resolver o sistema de forma trivial, isto é, definimos um valor positivo arbitrário para $x_n$ e ir calculando os valores de $x_{n-1}$ até $x_1$. Normalizando o auto-vetor ao final, temos um resultado padronizado que independe da escolha do valor de $x_n$.
    		
    		
    	\subsubsection{Complexidade}
    		Para calcular a complexidade, consideremos que a função recebe como parametros a matriz de ligação $M$ da forma $n\times n$ e o \emph{alpha}. Primeiro devemos computar a matriz \hspace{3em} $M = (1-\alpha)M - \alpha S$ e a matriz $A = M-I$, processos que podem ser realizados simultaneamente em $n^2$ repetições. 
    		
    		Agora ocorre o processo de escalonamento por Eliminação Gaussiana. Como descrito na apresentação do projeto, afim de tornar o algoritmo mais robusto, adotamos uma estratégia de pivotamento, esta é, trocar sempre o elemento que ocupa a posição de pivo pelo o elemento com maior valor em modulo da respectiva coluna, não sendo somente quando nulo. Decidido o elemento que será o pivo, temos que, estando esse elemento na posição $a_{k,k}$, faremos um total de $k^2$ repetições para deixar nulo todos os elementos abaixo do que será o pivo.  temos que o número de repetições pode ser dado por:
    		\[(n + (n-1)^2) + ((n-1) + (n-2)^2) + ((n-2) + (n-3)^2) + ... + ((2) + (1)^2)\]
    		
    		Sabendo que $\sum_{k=1}^n k^2 = \tfrac{n(n+1)(2n+1)}{6}$:
    		
    		\[ = \dfrac{n(n+2)}{2} + \dfrac{(n-1)(n)(2n-1)}{6} = \dfrac{2n^3 + 7n}{6} = \dfrac{1}{3}n^3 + \dfrac{7}{6}n\] 
    		
    		
    		Com a matriz escalonada, só precisamos terminar de resolver o sistema e calcular a soma das componentes do vetor. Inicializado o valor de $x_n$, temos que o valor de $x_k$ é dado por $x_k = (-\sum_{j=k+1}^{n}a_{k,j}x_j)/a_{k,k}$. Podemos calcular a soma das componentes simplesmente inicializando a soma com o valor de $x_n$ e somando cada valor de $x_k$ calculado a soma em cada interação. Portanto variando o valor de $k$ entre $n-1$ e $1$, temos que o número de repetições será $\tfrac{(n-1)(n)}{2} = \tfrac{1}{2}n^2 - \tfrac{1}{2}n$.
    		
    		Por último, tendo o valor da soma das componentes do vetor $x$, iremos fazer $n$ repetições afim de normalizar o vetor.
    		
    		Portanto somando os números de repetições de cada processo chegamos em:
    		
    			\[n^2 + \dfrac{1}{3}n^3 + \dfrac{7}{6}n + \dfrac{1}{2}n^2 - \dfrac{1}{2}n + n= \dfrac{1}{3}n^3 + \dfrac{3}{2}n^2 + \dfrac{5}{3}n\]
    			
    		Resultando em uma complexidade de $O(n^3)$.
    
    
    \subsection{Método 2 - Método das potências}
		\subsubsection{Visão geral}	
		
		\subsubsection{Complexidade}	
			Temos duas etapas que depende de grande uso computacional: quando necessitamos analisar a matriz $M$ para construir as matrizes $V$, $L$ e $C$, e quando multiplicamos a matriz $M$ por $x$ até que o erro seja menor que $10^{-5}$. Na primeira parte temos uma complexidade de $O(n^2)$, já que necessitamos checar $n^2 - n$ componentes da matriz (diagonal é nula). Na segunda parte fazemos um número L de vezes a multiplicação de $M$ por $x$, além disso cada multiplicação faz $m$ repetições, sendo $m$ a quantidade de valores não nulos de $M$. Depois de multiplicar precisamos calcular o erro, copiar o resultado da matriz resultante para outra e zerar as componentes para uma nova multiplicação, para isso fazemos $n$ repetições. Portanto essa segunda parte faz um total de $L(m + n)$ repetições. Como o valor de máximo de $m$ não é interessante, já que implicaria que a importância seria $1/n$ para todas as páginas, então devemos analisar como o valor de L se comporta de acordo com o valor de m aumentando. Testando com modelos \emph{cacique-tribo} com grupos de 5 a 60, temos que:
			
			\begin{figure}
  				\centering
  				\includegraphics[width=0.7\linewidth]{figure_m_L.png}
  				\caption{Comparação dos valores de m e L} \label{fig:M1}
			\end{figure}

		
			Percebemos que o valor de $L$ não aumenta quase nada em comparação com o valor de m. Logo o impacto de L é baixo, então podemos considerar a complexidade do algoritmo como sendo $O(n^2)$.
			
			\begin{figure}
  				\centering
  				\includegraphics[width=0.7\linewidth]{figure_L.png}
  				\caption{Valores de L conforme a quantidade de grupos aumenta} \label{fig:M1}
			\end{figure}

\newpage

\section{Programa}
	O programa foi feito em Python (3.7), sem usos de bibliotecas adicionais. A entrada do programa consiste na entrada do grafo respectivo a rede de páginas que deve ser analisada. Para leitura do grafo usamos uma forma de representação chamada Lista de Adjacências que consiste em criar um vetor para cada vértice do grafo, esse vetor tem todos os vértices para o qual o vértice tem uma aresta. A utilização desse método de representação foi feita de modo possibilitar uma maior facilidade na visualização do que está sendo inserido.

	Dado grafo a seguir:
		\begin{figure}[!hb]
			\centering
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt, main node/.style={circle,draw,font=\Large\bfseries}]

				\foreach \place/\name in {{(0,-1)/1}, {(1.75,0)/2}, {(1.5,2)/3}, {(-1.5,2)/4}, {(-1.75,0)/5}}	
					\node[main node] (\name) at \place {\name};
					
				\foreach \source/\dest in {1/2,2/1,3/4,4/2,5/1,3/5, 1/4}
					\path (\source) edge (\dest);
			\end{tikzpicture}
			\vspace{0.25cm}
			\caption{Grafo exemplo} \label{fig:M1}
		\end{figure}
		
	Exemplo de entrada:
	
		\begin{lstlisting}
			5 			# Numeros de grafos
			0.15 		# Alpha
			1 2			# Vertice u aponta para o Vertice v
			1 4
			2 1
			3 4
			3 5
			4 2
			5 1
			0 0			# Fim da insercao de arestas
		\end{lstlisting}
	
	A saída consiste em opções de classificação do rank  de acordo com cada método e análise dos métodos, que mostra tempo de execução de cada método, número de repetições do método interativo, maior e menor diferença entre a importância calculada por cada método, etc. 
	Também foram feitos testes automatizados usando Shell script e alguns dos seus resultados serão visto na próxima seção. Essa parte do projeto de testes pode ser encontrada no Github\footnote{https://github.com/pedro913/pageRank}, que contém resultados de outros testes.
	
	
\vspace{3em}

\section{Tarefas}
	\subsection{Tarefa 1}
		
	\subsection{Tarefa 2}
		
\end{document}
